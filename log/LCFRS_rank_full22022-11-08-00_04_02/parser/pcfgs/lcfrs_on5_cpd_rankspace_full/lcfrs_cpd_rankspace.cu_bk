#include <stdio.h>
#include <cuda_runtime.h>


float logsumexpf(float x, float y) {
  if (y <= x)
    return x + log1pf(expf(y - x));
  else
    return y + log1pf(expf(x - y));
}


__global__ void kernel_forward_root( float * root_c,
                                     float * root_d,
                                     float * alpha_l,
                                     float * alpha_r,
                                     float * alpha_cc,
                                     float * alpha_cd,
                                     int B,  int L, int r1, int r2)
{
    int b_idx = blockIdx.x;
    int s_R = threadIdx.x;

    __shared__ float result_l[1000];
    __shared__ float result_r[1000];
    __shared__ float result_c[200];
    __shared__ float result_d1[200];
    __shared__ float result_d2[200];
    __shared__ float result_d3[200];
    __shared__ float result_d4[200];

    int start = 0;
    int end = L;
    float *  s_l = alpha_l + b_idx * L * L * r1;
    float *  s_r = alpha_r + b_idx * L * L * r1;
    float *  s_cc = alpha_cc + b_idx * L * L * r2;
    float *  s_cd = alpha_cd + b_idx * L * L * L * L * r2;
    int L3 = L*L*L*r2;
    int L2 = L*L*r2;
    int L1 = L*r2;

    float tmp_result = logf(0);
    float tmp_result2 = logf(0);

    for (int split = start+1; split < start+width; split++)
    {
        tmp_result = logsumexpf(tmp_result, s_l[start*L*r1 + split * r1 + s_R] + s_r[split*L*r1 + end*r1 + s_R]);
        if(s_R < r2){
            for(int split2 = split+1; split2 < start+width; split2++){
               tmp_result2 = logsumexpf(tmp_result2, s_cc[split*L*r2 + split2*r2 + s_R] + s_cd[start*L3 + split*L2 + split2*L1 + s_R]);
            }
        }
    }

    result[s_R] = tmp_result + root_c[b_idx*r1 + s_R];

    if(s_R < r2){
        result[s_R] = logsumexpf(result[s_R], tmp_result2 + root_d[b_idx*r2 + s_R]);
    }
    __syncthreads();

    if(s_R==0){
        float final_result = logf(0);
        for(int i=0;i<r1;i++){
            final_result = logsumexpf(final_result, result[i]);
        }
        s_l[start*L*r1 + end*L*r1 + 0] = final_result;
    }
}

__global__ void kernel_backward_root( float * root_c,
                                     float * root_d,
                                     float * alpha_l,
                                     float * alpha_r,
                                     float * alpha_cc,
                                     float * alpha_cd,
                                     float * alpha_dc,
                                     int B,   int L, int width, int r1, int r2)
{
    int b_idx = blockIdx.x;
    int start = blockIdx.y;
    int s_A = blockIdx.z;
    int s_R = threadIdx.x;

    if(start+width >= L){
        return;
    }

    __shared__ float result_l[1000];
    __shared__ float result_r[1000];
    __shared__ float result_c[200];
    __shared__ float result_d1[200];
    __shared__ float result_d2[200];
    __shared__ float result_d3[200];
    __shared__ float result_d4[200];

    int end = start + width;
    float *  s_l = alpha_l + b_idx * L * L * r1;
    float *  s_r = alpha_r + b_idx * L * L * r1;
    float *  s_cc = alpha_cc + b_idx * L * L * r2;
    float *  s_cd = alpha_cd + b_idx * L * L * L * L * r2;
    int L3 = L*L*L*r2;
    int L2 = L*L*r2;
    int L1 = L*r2;

    float tmp_result = logf(0);
    float tmp_result2 = logf(0);

    for (int split = start+1; split < start+width; split++)
    {
        tmp_result = logsumexpf(tmp_result, s_l[start*L*r1 + split * r1 + s_R] + s_r[split*L*r1 + end*r1 + s_R]);
        if(s_R < r2){
            for(int split2 = split+1; split2 < start+width; split2++){
               tmp_result2 = logsumexpf(tmp_result2, s_cc[split*L*r2 + split2*r2 + s_R] + s_cd[start*L3 + split*L2 + split2*L1 + s_R]);
            }
        }
    }

    result[s_R] = tmp_result + root_c[b_idx*r1 + s_R];

    if(s_R < r2){
        result[s_R] = logsumexpf(result[s_R], tmp_result2 + root_d[b_idx*r2 + s_R]);
    }
    __syncthreads();

    if(s_R==0){
        float final_result = logf(0);
        for(int i=0;i<r1;i++){
            final_result = logsumexpf(final_result, result[i]);
        }
        s_l[start*L*r1 + end*L*r1 + 0] = final_result;
    }
}



__global__ void kernel_forward( float *  head_cl1,
                                float *  head_cr1,
                                float *  head_cc1,
                                float *  head_dc1,
                                float *  head_cl2,
                                float *  head_cr2,
                                float *  head_cc2,
                                float *  head_dc2,
                                float * alpha_l,
                                float * alpha_r,
                                float * alpha_cc,
                                float * alpha_cd,
                                float * alpha_dc,
                                int B,   int L, int width, int r1, int r2)
{
    int b_idx = blockIdx.x;
    int start = blockIdx.y;
    int s_A = blockIdx.z;
    int s_R = threadIdx.x;

    if(start+width >= L){
        return;
    }

    __shared__ float result_l[1000];
    __shared__ float result_r[1000];
    __shared__ float result_c[200];
    __shared__ float result_d1[200];
    __shared__ float result_d2[200];
    __shared__ float result_d3[200];
    __shared__ float result_d4[200];

    int end = start + width;
    float *  s_l = alpha_l + b_idx * L * L * r1;
    float *  s_r = alpha_r + b_idx * L * L * r1;
    float *  s_cc = alpha_cc + b_idx * L * L * r2;
    float *  s_cd = alpha_cd + b_idx * L * L * L * L * r2;
    int L3 = L*L*L*r2;
    int L2 = L*L*r2;
    int L1 = L*r2;

    float tmp_result = logf(0);
    float tmp_result2 = logf(0);

    for (int split = start+1; split < start+width; split++)
    {
        tmp_result = logsumexpf(tmp_result, s_l[start*L*r1 + split*r1 + s_R] + s_r[split*L*r1 + end*r1 + s_R]);
        if(s_R < r2){
            for(int split2 = split+1; split2 < start+width; split2++){
               tmp_result2 = logsumexpf(tmp_result2, s_cc[split*L*r2 + split2*r2 + s_R] + s_cd[start*L3 + split*L2 + split2*L1 + s_R]);
            }
        }
    }

    result_l[s_R] = tmp_result + head_cl1[b_idx*r1*r1 + s_A*r1 + s_R];
    result_r[s_R] = tmp_result + head_rl1[b_idx*r1*r1 + s_A*r1 + s_R];

    if (s_A < r2){
       result_c[s_R] = tmp_result + head_cc1[b_idx*r1*r2 + s_A*r1 + s_R];
       result_d1[s_R] = tmp_result + head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 0*r1 + s_R];
       result_d2[s_R] = tmp_result + head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 1*r1 + s_R];
       result_d3[s_R] = tmp_result + head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 2*r1 + s_R];
       result_d4[s_R] = tmp_result + head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 3*r1 + s_R];
    }

    if(s_R < r2){
        result_l[s_R] = logsumexpf(result_l[s_R], tmp_result2 + head_cl2[b_idx*r1*r2 + s_A*r2 + s_R];
        result_r[s_R] = logsumexpf(result_r[s_R], tmp_result2 + head_cr2[b_idx*r1*r2 + s_A*r2 + s_R];

        if (s_A < r2){
             result_c[s_R] = logsumexpf(result_c[s_R], tmp_result2 + head_cc2[b_idx*r2*r2 + s_A*r2 + s_R];
             result_d1[s_R] = logsumexpf(result_d1[s_R], tmp_result2 + head_dc2[b_idx*r2*r2*4 + s_A*r2*4 + 0*r2 + s_R];
             result_d2[s_R] = logsumexpf(result_d2[s_R], tmp_result2 + head_dc2[b_idx*r2*r2*4 + s_A*r2*4 + 1*r2 + s_R];
             result_d3[s_R] = logsumexpf(result_d3[s_R], tmp_result2 + head_dc2[b_idx*r2*r2*4 + s_A*r2*4 + 2*r2 + s_R];
             result_d4[s_R] = logsumexpf(result_d4[s_R], tmp_result2 + head_dc2[b_idx*r2*r2*4 + s_A*r2*4 + 3*r2 + s_R];
        }

    __syncthreads();

    if(s_R==0){
        float final_result_l = logf(0);
        float final_result_r = logf(0);

        for(int i=0;i<r1;i++){
            final_result_l = logsumexpf(final_result_l, result_l[i]);
            final_result_r = logsumexpf(final_result_l, result_r[i]);
        }

        alpha_l[b_idx*L*L*r1 +start*L*r1 +end*r1 + s_A] = final_result_l;
        alpha_r[b_idx*L*L*r1 +start*L*r1 +end*r1 + s_A] = final_result_r;

        if(s_A < r2){

            float final_result_c = logf(0);
            float final_result_d1 = logf(0);
            float final_result_d2 = logf(0);
            float final_result_d3 = logf(0);
            float final_result_d4 = logf(0);

            for(int i = 0; i < r1; i++){
               final_result_c = logsumexpf(final_result_c, result_c[i]);
               final_result_d1 = logsumexpf(final_result_d1, result_d1[i]);
               final_result_d2 = logsumexpf(final_result_d2, result_d2[i]);
               final_result_d3 = logsumexpf(final_result_d3, result_d3[i]);
               final_result_d4 = logsumexpf(final_result_d4, result_d4[i]);
            }
            alpha_cc[b_idx*L*L*r2 + start*L*r2 +end*r2 + s_A] = final_result_c;
            alpha_cd[b_idx*L*L*r2*4 + start*L*r2*4 +end*r2*4 + 0*r2 + s_A] = final_result_d1;
            alpha_cd[b_idx*L*L*r2*4 + start*L*r2*4 +end*r2*4 + 1*r2 + s_A] = final_result_d2;
            alpha_cd[b_idx*L*L*r2*4 + start*L*r2*4 +end*r2*4 + 2*r2 + s_A] = final_result_d3;
            alpha_cd[b_idx*L*L*r2*4 + start*L*r2*4 +end*r2*4 + 3*r2 + s_A] = final_result_d4;
        }
    }
}

__global__ void kernel_backward( float *  head_cl1,
                                 float *  head_cr1,
                                 float *  head_cc1,
                                 float *  head_dc1,
                                 float *  head_cl2,
                                 float *  head_cr2,
                                 float *  head_cc2,
                                 float *  head_dc2,

                                 float *  head_cl1_grd,
                                 float *  head_cr1_grd,
                                 float *  head_cc1_grd,
                                 float *  head_dc1_grd,
                                 float *  head_cl2_grd,
                                 float *  head_cr2_grd,
                                 float *  head_cc2_grd,
                                 float *  head_dc2_grd,

                                 float * alpha_l,
                                 float * alpha_r,
                                 float * alpha_cc,
                                 float * alpha_cd,
                                 float * alpha_dc,

                                 int B,   int L,   int width,   int m,   int r)
{
      int b_idx = blockIdx.x;
      int start = blockIdx.y;
      int s_A = blockIdx.z;
      int s_R = threadIdx.x;

      if(start+width >= L){
        return;
      }

      int end = start + width;
      float *  s_l = alpha_l + b_idx * L * L * r1;
      float *  s_r = alpha_r + b_idx * L * L * r1;
      float *  s_cc = alpha_cc + b_idx * L * L * r2;
      float *  s_cd = alpha_cd + b_idx * L * L * L * L * r2;
      float *  s_dc = alpha_dc + b_idx * L * L * r2 * 4;

      int L3 = L*L*L*r2;
      int L2 = L*L*r2;
      int L1 = L*r2;

      float parent_inside_l = alpha_l[start * L * r1 + end * r1 + s_A];
      float parent_grd_l = alpha_l[end * L * r1 + start * r1 + s_A];

      float parent_inside_r = alpha_r[start * L * r1 + end * r1 + s_A];
      float parent_grd_r = alpha_r[end * L * r1 + start * r1 + s_A];

      float parent_inside_cc = alpha_cc[start * L * r2 + end * r2 + s_A];
      float parent_grd_cc = alpha_cc[end * L * r2 + start * r2 + s_A];

      float parent_inside_dc1 = alpha_dc[start * L * r2 * 4 + end * r2 * 4 + 0 * r2 + s_A];
      float parent_inside_dc2 = alpha_dc[start * L * r2 * 4 + end * r2 * 4 + 1 * r2 + s_A];
      float parent_inside_dc3 = alpha_dc[start * L * r2 * 4 + end * r2 * 4 + 2 * r2 + s_A];
      float parent_inside_dc4 = alpha_dc[start * L * r2 * 4 + end * r2 * 4 + 3 * r2 + s_A];

      float parent_grd_dc1 = alpha_dc[end * L * r2 * 4 + start * r2 * 4 + 0 * r2 + s_A];
      float parent_grd_dc2 = alpha_dc[end * L * r2 * 4 + start * r2 * 4 + 1 * r2 + s_A];
      float parent_grd_dc3 = alpha_dc[end * L * r2 * 4 + start * r2 * 4 + 2 * r2 + s_A];
      float parent_grd_dc4 = alpha_dc[end * L * r2 * 4 + start * r2 * 4 + 3 * r2 + s_A];

      float cl1 = head_cl1[b_idx*r1*r1 + s_A*r1 + s_R];
      float cr1 = head_cr1[b_idx*r1*r1 + s_A*r1 + s_R];
      float cc1 = head_cc1[b_idx*r1*r2 + s_A*r1 + s_R];

      float cl1_grd = 0;
      float cr1_grd = 0;
      float cc1_grd = 0;

      float dc11 = head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 0*r1 + s_R];
      float dc12 = head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 1*r1 + s_R];
      float dc13 = head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 2*r1 + s_R];
      float dc14 = head_dc1[b_idx*r1*r2*4 + s_A*r1*4 + 3*r1 + s_R];

      float dc11_grd = 0;
      float dc12_grd = 0;
      float dc13_grd = 0;
      float dc14_grd = 0;

     for (int split = start+1; split < start+width; split++)
     {
        float tmp = s_l[start*L*r + split * r + s_R] + s_r[split*L*r + end*r + s_R]);
        float grd = 0;

        float tmp_grd = expf(tmp + cl1 - parent_inside_l) * parent_grd_l;
        grd += tmp_grd1;
        cl1_grd += tmp_grd1;

        tmp_grd = expf(tmp + cr1 - parent_inside_r) * parent_grd_r;
        grd += tmp_grd2;
        cr1_grd += tmp_grd2;

        if(s_A < r2){
             tmp_grd = expf(tmp + cc1 - parent_inside_cc) * parent_grd_cc;
             grd += tmp_grd;
             cc1_grd += tmp_grd;

             tmp_grd = expf(tmp + dc11 - parent_inside_dc1) * parent_grd_dc1;
             grd += tmp_grd;
             dc11_grd += tmp_grd;

             tmp_grd = expf(tmp + dc12 - parent_inside_dc2) * parent_grd_dc2;
             grd += tmp_grd;
             dc12_grd += tmp_grd;

             tmp_grd = expf(tmp + dc13 - parent_inside_dc3) * parent_grd_dc3;
             grd += tmp_grd;
             dc13_grd += tmp_grd;

             tmp_grd = expf(tmp + dc14 - parent_inside_cd11) * parent_grd_dc4;
             grd += tmp_grd;
             dc14_grd += tmp_grd;
        }

        atomicAdd(s_l + split*L*r + start*r + s_R, grd);
        atomicAdd(s_r + end*L*r + split + s_R, grd);

        if(s_R < r2){

            for(int split2 = split+1; split2 < start+width; split2++){
                float tmp = s_cc[split*L*r2 + split2*r2 + s_R] + s_cd[start*L3 + split*L2 + split2*L1 + end*r2 + s_R];
                float grd = 0;

                float tmp_grd = expf(tmp + cl2 - parent_inside_l) * parent_grd_l;
                cl2_grd += tmp_grd;
                grd += tmp_grd;

                tmp_grd = expf(tmp + cl2 - parent_inside_l) * parent_grd_l;
                cl2_grd += tmp_grd;
                grd += tmp_grd;

                if(s_A < r2){
                    float tmp_grd = expf(tmp + cc2 - parent_inside_cc) * parent_grd_cc;
                    cc2_grd += tmp_grd;
                    grd += tmp_grd;

                    tmp_grd = expf(tmp + dc21 - parent_inside_d1) * parent_grd_d1;
                    dc21_grd += tmp_grd;
                    grd += tmp_grd;

                    tmp_grd = expf(tmp + dc22 - parent_inside_d2) * parent_grd_d2;
                    dc22_grd += tmp_grd;
                    grd += tmp_grd;

                    tmp_grd = expf(tmp + dc21 - parent_inside_d1) * parent_grd_d1;
                    dc21_grd += tmp_grd;
                    grd += tmp_grd;

                    tmp_grd = expf(tmp + dc21 - parent_inside_d1) * parent_grd_d1;
                    dc21_grd += tmp_grd;
                    grd += tmp_grd;
                }
                atomicAdd(s_cc + split2*L*r2 + split*r2 + s_R, grd);
                atomicAdd(s_cd + split*L3 + start*L2 + split2*L1 + end*r2 + s_R, grd);
            }
        }
        }

     atomicAdd( head_cl1_grd + b_idx * r1 * r1 + s_A * r1 + s_R, cl1_grd);
     atomicAdd( head_cr1_grd + b_idx * r1 * r1 + s_A * r1 + s_R, cr1_grd);

     if(s_A < r2){
         atomicAdd( head_cc1_grd + b_idx * r1 * r2 + s_A * r1 + s_R, cr1_grd);
         atomicAdd( head_dc1_grd + b_idx * r1 * r2*4 + s_A * r2 * 4 + 0*r2 + s_R, dc11_grd );
         atomicAdd( head_dc1_grd + b_idx * r1 * r2*4 + s_A * r2 * 4 + 1*r2 + s_R, dc12_grd );
         atomicAdd( head_dc1_grd + b_idx * r1 * r2*4 + s_A * r2 * 4 + 2*r2 + s_R, dc13_grd );
         atomicAdd( head_dc1_grd + b_idx * r1 * r2*4 + s_A * r2 * 4 + 3*r2 + s_R, dc14_grd );
     }

     if (s_R < r2){
        atomicAdd( head_cl2_grd + b_idx * r1 * r2 + s_A * r2 + s_R, cl2_grd);
        atomicAdd( head_cr2_grd + b_idx * r1 * r2 + s_A * r2 + s_R, cr2_grd);
        if(s_A < r2){
            atomicAdd( head_cc2_grd + b_idx * r2 * r2 + s_A * r2 + s_R, cc2_grd);
            atomicAdd( head_dc2_grd + b_idx * r2 * r2 * 4 + s_A*r2*4 + 0*r2 + s_R, dc21_grd);
            atomicAdd( head_dc2_grd + b_idx * r2 * r2 * 4 + s_A*r2*4 + 1*r2 + s_R, dc22_grd);
            atomicAdd( head_dc2_grd + b_idx * r2 * r2 * 4 + s_A*r2*4 + 2*r2 + s_R, dc23_grd);
            atomicAdd( head_dc2_grd + b_idx * r2 * r2 * 4 + s_A*r2*4 + 3*r2 + s_R, dc24_grd);
        }
     }
}




__global__ void kernel_forward_d1( float *  head_cd,
                                   float * head_dd,
                                   float * alpha_dl,
                                   float * alpha_dr,
                                   float * alpha_cd,
                                   float * alpha_dd,
                                   int B,  int L,   int width,   int r1,   int r2)
{
      int b_idx = blockIdx.x / (L-width);
      int start = blockIdx.x % (L-width);
      int gap_start_minus_start = (blockIdx.y) / (L-width);
      int gap_width =  ((blockIdx.y) % ( L-width)) + 1;
      int end = start + width + gap_width;
      if(end>=L){
        return;
      }
      int s_A = (blockIdx.z);
      int s_R = threadIdx.x;
      int gap_start = start + gap_start_minus_start + 1;
      int gap_end = gap_start + gap_width;
      if(gap_start - start > width-1)
      {
         return;
      }

    __shared__ float result[1000];
    __shared__ float result2[1000];
    __syncthreads();

    float *   s_l = alpha_dl + b_idx * L * L * r;
    float *   s_r = alpha_dr + b_idx * L * L * r;
    float tmp =  s_l[start*L*r + gap_start*r + s_R] + s_r[gap_end*L*r + end*r + s_R];
    result[s_R] = tmp + head_cd[b_idx*d*r + s_R*d + s_A];
    result2[s_R] = tmp + head_dd[b_idx*d*r + s_R*d + s_A];
    __syncthreads();

    if(s_R==0){
    float final_result = logf(0);
    float final_result2 = logf(0);
    for(int i=0;i<r;i++){
        final_result = logsumexpf(final_result, result[i]);
        final_result2 = logsumexpf(final_result2, result2[i]);
    }
    alpha_cd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A] = final_result;
    alpha_dd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A] = final_result2;
    }
}




__global__ void kernel_backward_d1(  float*   head_cd, float *   head_cd_grd,
                                     float*   head_dd, float * head_dd_grd,
                                     float* alpha_ld,
                                     float* alpha_rd,
                                     float* alpha_cd,
                                     float* alpha_dd,
                                     int B,   int L,   int width,   int d,   int r)
{
      int b_idx = blockIdx.x / (L-width);
      int start = blockIdx.x % (L-width);
      int gap_start_minus_start = (blockIdx.y) / (L-width);
      int gap_width =  ((blockIdx.y) % ( L-width)) + 1;
      int end = start + width + gap_width;
      if(end>=L){
        return;
      }
      int s_A = (blockIdx.z);
      int s_R = threadIdx.x;
      int gap_start = start + gap_start_minus_start + 1;
      int gap_end = gap_start + gap_width;
      if(gap_start - start > width-1)
      {
         return;
      }
     float *   s_l = alpha_ld + b_idx * L * L * r;
     float *   s_r = alpha_rd + b_idx * L * L * r;

     float parent_inside = alpha_cd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A];
     float parent_grd = alpha_cd[b_idx*L*L*L*L*d + gap_start*L*L*L*d + start*L*L*d + gap_end*L*d + end*d + s_A];
     float tmp = (s_l[start*L*r + gap_start*r + s_R] + s_r[gap_end*L*r + end*r + s_R]);
     float tmp_grd =  expf(tmp + head_cd[b_idx*d*r+s_R*d+s_A] - parent_inside)*parent_grd;
     atomicAdd(head_cd_grd + b_idx*d*r + s_R*d + s_A, tmp_grd);

     parent_inside = alpha_dd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A];
     parent_grd = alpha_dd[b_idx*L*L*L*L*d + gap_start*L*L*L*d + start*L*L*d + gap_end*L*d + end*d + s_A];
     float tmp_grd2 = expf(tmp + head_dd[b_idx*d*r+s_R*d+s_A] - parent_inside)*parent_grd;
     atomicAdd(s_l + gap_start*L*r + start*r + s_R, tmp_grd+tmp_grd2);
     atomicAdd(s_r + end*L*r + gap_end*r + s_R, tmp_grd+tmp_grd2);
     atomicAdd(head_dd_grd + b_idx*d*r + s_R*d + s_A, tmp_grd2);
}


__global__ void kernel_forward_d2(float *  head_cd,
                                float *  head_dd,
                                float * alpha_dc,
                                float * alpha_dd,
                                float * alpha_cd,
                                int B,  int L,  int width,   int d,   int r)
{
      int b_idx = blockIdx.x / (L-width);
      int start = blockIdx.x % (L-width);
      int gap_start_minus_start = (blockIdx.y) / (L-width);
      int gap_width =  ((blockIdx.y) % ( L-width)) + 1;
      int end = start + width + gap_width;
        if(end>=L){
        return;
        }
     int s_A = (blockIdx.z);
     int s_R = threadIdx.x;
     int gap_start = start + gap_start_minus_start + 1;
     int gap_end = gap_start + gap_width;
     if(gap_start - start > width-1)
     {
        return;
     }

     float *   s = alpha_dc + b_idx * L * L * r * 4;
     float *   s_d = alpha_dd + b_idx * L * L * L * L * r;
     int L3 = L * L * L * r;
     int L2 = L * L * r;
     int L1 = L * r;
     float tmp_result = logf(0);
     __shared__ float result[200];
     __shared__ float result2[200];
     __syncthreads();
     for(int split=start+1; split< gap_start; split++)
     {
        tmp_result = logsumexpf(tmp_result, s_d[split*L3 + gap_start*L2 + gap_end*L1 + end*r + s_R] + s[start*L*r*4 + split*r*4 +  0*r + s_R]);
        tmp_result = logsumexpf(tmp_result, s_d[start*L3 + split*L2 + gap_end*L1 + end*r + s_R] + s[split*L*r*4 + gap_start*r*4 + 1*r + s_R]);
     }

     for(int split = gap_end+1; split <end; split++){
        tmp_result = logsumexpf(tmp_result, s_d[start*L3 + gap_start*L2 + split*L1 + end*r + s_R] + s[gap_end*L*r*4 + split*r*4 + 2*r + s_R]);
        tmp_result = logsumexpf(tmp_result, s_d[start*L3 + gap_start*L2 + gap_end*L1 + split*r + s_R] + s[split*L*r*4 + end*r*4 + 3*r + s_R]);
     }

     result[s_R] = tmp_result + head_cd[b_idx*d*r + s_R*r + s_A];
     result2[s_R] = tmp_result + head_dd[b_idx*d*r + s_R*r + s_A];
     __syncthreads();

     if(s_R==0){
        float final_result = logf(0);
        float final_result2 = logf(0);
        for(int i=0;i<r;i++){
            final_result = logsumexpf(final_result, result[i]);
            final_result2 = logsumexpf(final_result2, result2[i]);
        }
        alpha_cd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A] = logsumexpf(alpha_cd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A],final_result);
        alpha_dd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A] = logsumexpf( alpha_dd[b_idx*L*L*L*L*d + start*L*L*L*d + gap_start*L*L*d + gap_end*L*d + end*d + s_A],final_result2);
    }
}

__global__ void kernel_backward_d2(float *  head_cd, float *  head_cd_grd,
                                float *  head_dd, float *  head_dd_grd,
                                float * alpha_dc,
                                float * alpha_dd,
                                float * alpha_cd,
                                int B,  int L,  int width,   int d,   int r)
{
    const int b_idx = blockIdx.x / (L-width);
    const int start = blockIdx.x % (L-width);
    const int gap_start_minus_start = (blockIdx.y) / (L-width);
    const int gap_width =  ((blockIdx.y) % ( L-width)) + 1;
    const int end = start + width + gap_width;
    if(end>=L){
        return;
    }
    const int s_A = (blockIdx.z);
    const int s_R = threadIdx.x;
    const int gap_start = start + gap_start_minus_start + 1;
    const int gap_end = gap_start + gap_width;
    if(gap_start - start > width-1)
    {
        return;
    }

    float * s = alpha_dc + b_idx * L * L * r * 4;
    float * s_d = alpha_dd + b_idx * L * L * L * L * r;
    int L3 = L * L * L * d;
    int L2 = L * L * d;
    int L1 = L * d;
    float tmp_result = logf(0);

    float rule_score1 = head_cd[b_idx*d*r + s_R*d + s_A];
    float rule_score2 = head_dd[b_idx*d*r + s_R*d + s_A];
    float rule_grd = 0;
    float rule_grd2 = 0;

    float parent_inside = alpha_cd[b_idx*L*L*L*L*d + start*L3 + gap_start*L2 + gap_end*L1 + end*d + s_A];
    float parent_grd = alpha_cd[b_idx*L*L*L*L*d + gap_start*L3 + start*L2 + gap_end*L1 + end*d + s_A];
    float parent_inside2 = alpha_dd[b_idx*L*L*L*L*d + start*L3 + gap_start*L2 + gap_end*L1 + end*d + s_A];
    float parent_grd2 = alpha_dd[b_idx*L*L*L*L*d + gap_start*L3 + start*L2 + gap_end*L1 + end*d + s_A];

    L3 = L*L*L*r;
    L2 = L*L*r;
    L1 = L*r;
    for(int split=start+1; split< gap_start; split++)
    {
        float tmp = s_d[split*L3 + gap_start*L2 + gap_end*L1 + end*r + s_R] + s[start*L*r*4 + split*r*4 + 0*r + s_R];
        float grd1 = expf(tmp + rule_score1 - parent_inside) * parent_grd;
        rule_grd += grd1;
        float grd2 = expf(tmp + rule_score2 - parent_inside2) * parent_grd2;
        rule_grd2 += grd2;
        atomicAdd(s_d + gap_start*L3 + split*L2 + gap_end*L1 + end*r + s_R, grd1+grd2);
        atomicAdd(s + split*L*r*4 + start*r*4 + 0*r + s_R, grd1+grd2);

        tmp = s_d[start*L3 + split*L2 + gap_end*L1 + end*r + s_R]  + s[split*L*r*4 + gap_start*r*4 + 1*r + s_R];
        grd1 = expf(tmp + rule_score1 - parent_inside) * parent_grd;
        rule_grd += grd1;
        grd2 = expf(tmp + rule_score2 - parent_inside2) * parent_grd2;
        rule_grd2 += grd2;
        atomicAdd(s_d + split*L3 + start*L2 + gap_end*L1 + end*r + s_R, grd1+grd2);
        atomicAdd(s + gap_start*L*r*4 + split*r*4 + 1*r + s_R, grd1+grd2);
    }

    for(int split=gap_end+1; split <end; split++){
        float tmp = s_d[start*L3 + gap_start*L2 + split*L1 + end*r + s_R] + s[gap_end*L*r*4 + split*r*4 + 2*r + s_R];
        float grd1 = expf(tmp + rule_score1 - parent_inside) * parent_grd;
        rule_grd += grd1;
        float grd2 = expf(tmp + rule_score2 - parent_inside2) * parent_grd2;
        rule_grd2 += grd2;
        atomicAdd(s_d + gap_start*L3 + start*L2 + split*L1 + end*r + s_R, grd1+grd2);
        atomicAdd(s + split*L*r*4 + gap_end*r*4 + 2*r + s_R , grd1+grd2);

        tmp = s_d[start*L3 + gap_start*L2 + gap_end*L1 + split*r + s_R] + s[split*L*r*4 + end*r*4 + 3*r + s_R];
        grd1 = expf(tmp + rule_score1 - parent_inside) * parent_grd;
        rule_grd += grd1;
        grd2 = expf(tmp + rule_score2 - parent_inside2) * parent_grd2;
        rule_grd2 += grd2;
        atomicAdd(s_d + gap_start*L3 + start*L2 + gap_end*L1 + split*r + s_R, grd1+grd2);
        atomicAdd(s + end*L*r*4 + split*r*4 + 3*r + s_R, grd1+grd2);
    }
    atomicAdd(head_cd_grd + b_idx*d*r + s_R*d + s_A, rule_grd);
    atomicAdd(head_dd_grd + b_idx*d*r + s_R*d + s_A, rule_grd2);
}




void cuda_forward( float *head_cl1,  float *head_cr1,
                   float *head_cc1,  float *head_dc1,
                   float *head_cl2,  float *head_cr2,
                   float *head_cc2,  float *head_dc2,
                   float *head_cd1, float *head_cd2,
                   float *head_dd1, float *head_dd2,
                   float *root_c, float *root_d,
                   float *alpha_l, float *alpha_rc, float *alpha_ld, float *alpha_rd,
                   float *alpha_cc, float *alpha_cd, float *alpha_dc, float *alpha_dd,
                   int B, int L, int r1, int r2)
{
    for(int w=2; w<L-1; w++){
      dim3 gridDim(B, L-w, r1);
      dim3 blockDim(r1);
      kernel_forward<<<gridDim, blockDim>>>(head_cl1, head_cr1, head_cc1, head_dc1, head_cl2, head_cr2, head_cc2, head_cd2, head_dc2, alpha_lc, alpha_rc, alpha_cc, alpha_cd, alpha_dc,  B, L, w, r1, r2);

      dim3 gridDim3(B*(L-w),  (w-1)*(L-w), r);
      dim3 blockDim3(r3);
      kernel_forward_d1<<<gridDim3, blockDim3>>>(head_cd1, head_dd1, alpha_ld, alpha_rd, alpha_cd, alpha_dd, B, L, w, r2, r1);

      if(w>2){
            dim3 gridDim4(B*(L-w),  (w-1)*(L-w), r2);
            dim3 blockDim4(r4);
            kernel_forward_d2<<<gridDim4, blockDim4>>>(head_cd2, head_dd2, alpha_dc, alpha_dd, alpha_cd, B, L, w, r2, r2);
      }
    }

    dim3 gridDim3(B);
    dim3 blockDim3(r3);
    kernel_forward_root<<<gridDim3, blockDim3>>>(root_c, root_d, alpha_l, alpha_r, alpha_cc, alpha_cd, B, L, r1, r2);

}





}


void cuda_backward( float *head_c1,  float *head_c2,
                   float *left_c,   float *right_c,
                   float *left_d,   float *right_d,
                   float *cc,    float *dc,
                   float *head_cd1, float *head_cd2,
                   float *head_dd1, float *head_dd2,
                   float *unary,
                   float *head_c1_grd,  float *head_c2_grd,
                   float *left_c_grd,   float *right_c_grd,
                   float *left_d_grd,   float *right_d_grd,
                   float *cc_grd,    float *dc_grd,
                   float *head_cd1_grd, float *head_cd2_grd,
                   float *head_dd1_grd, float *head_dd2_grd,
                   float *unary_grd,
                   float *alpha, float *alpha_lc, float *alpha_rc, float *alpha_ld, float *alpha_rd,
                   float *alpha_cc, float *alpha_cd, float *alpha_dc, float *alpha_dd,
                   int B, int L, int m, int p, int d, int r1, int r2, int r3, int r4)
{
     for(int w=L-1; w>1; w--){

        if(w<L-1){

        if(w>2){
            dim3 gridDim4(B*(L-w),  (w-1)*(L-w), r2);
            dim3 blockDim4(r4);
            kernel_backward_d2<<<gridDim4, blockDim4>>>(head_cd2, head_cd2_grd, head_dd2, head_dd2_grd, alpha_dc, alpha_dd, alpha_cd, B, L, w, r2, r2);
        }
        dim3 gridDim3(B*(L-w),  (w-1)*(L-w), r2);
        dim3 blockDim3(r3);
        kernel_backward_d1<<<gridDim3, blockDim3>>>(head_cd1, head_cd1_grd, head_dd1, head_dd1_grd, alpha_ld, alpha_rd, alpha_cd, alpha_dd, B, L, w, r2, r1);

        dim3 gridDim9(B, L-w, r4);
        dim3 blockDim9(m);
        kernel_backward_dmr<<<gridDim9, blockDim9>>>(dc, dc_grd, alpha_dc, alpha, B, L, w, m, p, r4);

        dim3 gridDim8(B, L-w, r2);
        dim3 blockDim8(m);
        kernel_backward_cmr<<<gridDim8, blockDim8>>>(cc, cc_grd, alpha, alpha_cc, B, L, w, m, p, r2);

        dim3 gridDim7(B, L-w, r3);
        dim3 blockDim7(m);
        kernel_backward_cmr<<<gridDim7, blockDim7>>>(left_d, left_d_grd, alpha, alpha_ld,  B, L, w, m, p, r3);
        kernel_backward_cmr<<<gridDim7, blockDim7>>>(right_d, right_d_grd, alpha, alpha_rd,  B, L, w, m, p, r3);

        dim3 gridDim6(B, L-w, r1);
        dim3 blockDim6(m);
        kernel_backward_cmr<<<gridDim6, blockDim6>>>(left_c, left_c_grd, alpha, alpha_lc, B, L, w, m, p, r1);
        kernel_backward_cmr<<<gridDim6, blockDim6>>>(right_c, right_c_grd, alpha, alpha_rc, B, L, w, m, p, r1);
     }

    if (w>2){
        dim3 gridDim2(B, L-w, m);
        dim3 blockDim2(r2);
        kernel_backward_close<<<gridDim2, blockDim2>>>(head_c2, head_c2_grd, alpha, alpha_cd, alpha_cc, B, L, w, m, r2);
    }

    dim3 gridDim(B, L-w, m);
    dim3 blockDim(r1);
    kernel_backward<<<gridDim, blockDim>>>(head_c1, head_c1_grd, alpha, alpha_lc, alpha_rc, B, L, w, m, r1);
    }


    dim3 gridDim(B, L-1, r1);
    dim3 blockDim(p);
    kernel_backward_cpr<<<gridDim, blockDim>>>(right_c, right_c_grd, alpha_rc, unary, unary_grd, B, L, m, p, r1);
    kernel_backward_cpr<<<gridDim, blockDim>>>(left_c, left_c_grd, alpha_lc, unary, unary_grd, B, L, m, p, r1);
    dim3 gridDim11(B, L-1, r2);
    kernel_backward_cpr<<<gridDim11, blockDim>>>(cc, cc_grd, alpha_cc, unary, unary_grd, B, L, m, p, r2);
    dim3 gridDim12(B, L-1, r3);
    kernel_backward_cpr<<<gridDim12, blockDim>>>(left_d, left_d_grd, alpha_ld, unary, unary_grd, B, L, m, p, r3);
    kernel_backward_cpr<<<gridDim12, blockDim>>>(right_d, right_d_grd, alpha_rd, unary, unary_grd, B, L, m, p, r3);

    dim3 gridDim13(B, L-1, r4);
    kernel_backward_dpr<<<gridDim13, blockDim>>>(dc, dc_grd, alpha_dc, unary, unary_grd, B, L, m, p, r4);

}



template <typename F>
__global__ void kernel_argmax_c(const float * const s_span_c,
                                    float * alpha_c,
                                    float * alpha_d,
                                    int B,  int L,  int width
                                   )
{
     const int b_idx = blockIdx.x;
     const int start = threadIdx.x;
     float tmp_max = logf(0);
     float tmp_idx = -9999;
     int end = start + width;
     const int L2 = L*L;
     const int L3 = L2*L;
     const int L4 = L3*L;
     const float * const s_d = alpha_d + b_idx * L4;
     const float * const s_c = alpha_c + b_idx * L2;

     for(int split = start + 1; split < end; split+=1){
        float tmp = s_c[start*L+split] + s_c[split*L+end];
        if(tmp>tmp_max){
            tmp_max=tmp;
            tmp_idx=split;
        }
        for(int split2 =split+1;split2<end;split2+=1){
            tmp = s_c[split*L+split2] + s_d[start*L3+split*L2+split2*L+end];
            if(tmp>tmp_max){
                tmp_max=tmp;
                tmp_idx=-(split*L+split2);
            }
        }
     }
     alpha_c[b_idx*L*L + start*L + end] = tmp_max + s_span_c[b_idx*L*L+start*L + end];
     alpha_c[b_idx*L*L + end*L + start] = tmp_idx;
}


template <typename F>
__global__ void kernel_argmax_d(const float * const s_span_d,
                                    float * alpha_c,
                                    float * alpha_d,
                                    int B,  int L,  int width
                                   )
{
    const int b_idx = blockIdx.x ;
    const int gap_start_minus_start = blockIdx.y;
    const int gap_width = blockIdx.z + 1;
    const int start = threadIdx.x;
    const int end = start + width + gap_width;

    if(end>=L){
        return;
    }

    const int gap_start = start + gap_start_minus_start + 1;
    const int gap_end = gap_start + gap_width;

    if(gap_start - start >width-1)
    {
        return;
    }

    const int L2 = L*L;
    const int L3 = L2*L;
    const int L4 = L3*L;
    const float * const s_d = alpha_d + b_idx * L4;
    const float * const s_c = alpha_c + b_idx * L2;


    float tmp_max = s_c[start*L + gap_start] + s_c[gap_end*L + end];
    float tmp_idx = -1;

    for(int split=start + 1; split<gap_start; split++){
        float tmp = s_c[start*L + split] + s_d[split*L3+ gap_start*L2 + gap_end*L + end];
        if (tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = split;
        }
        tmp = s_c[split*L + gap_start] + s_d[start*L3 + split*L2 + gap_end*L + end];
        if ( tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = L + split;
         }
    }

    for(int split = gap_end+1; split < end; split++){
        float tmp = s_c[gap_end*L + split] + s_d[start*L3 + gap_start*L2 + split*L + end];
        if ( tmp > tmp_max){
           tmp_max = tmp;
           tmp_idx = 2*L + split;
         }
         tmp = s_c[split*L + end] + s_d[start*L3 + gap_start*L2 + gap_end*L + split];
         if (tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = 3*L + split;
         }
    }
    alpha_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end] = tmp_max + s_span_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end];
    alpha_d[b_idx*L4+gap_start*L3+start*L2+gap_end*L+end] = tmp_idx;
}

template <typename F>
__global__ void kernel_argmax_d_on3(const float * const s_span_d,
                                    float * alpha_c,
                                    float * alpha_d,
                                    int B,  int L,  int width
                                   )
{
    const int b_idx = blockIdx.x ;
    const int gap_start_minus_start = blockIdx.y;
    const int gap_width = blockIdx.z + 1;
    const int start = threadIdx.x;
    const int end = start + width + gap_width;

    if(end>=L){
        return;
    }

    const int gap_start = start + gap_start_minus_start + 1;
    const int gap_end = gap_start + gap_width;

    if(gap_start - start >width-1)
    {
        return;
    }

    const int L2 = L*L;
    const int L3 = L2*L;
    const int L4 = L3*L;
    const float * const s_d = alpha_d + b_idx * L4;
    const float * const s_c = alpha_c + b_idx * L2;


    float tmp_max = s_c[start*L + gap_start] + s_c[gap_end*L + end];
    float tmp_idx = -1;
    alpha_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end] = tmp_max + s_span_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end];
    alpha_d[b_idx*L4+gap_start*L3+start*L2+gap_end*L+end] = tmp_idx;
}

template <typename F>
__global__ void kernel_argmax_d_on6wn(const float * const s_span_d,
                                    float * alpha_c,
                                    float * alpha_d,
                                    int B,  int L,  int width
                               )
{
    const int b_idx = blockIdx.x;
    const int gap_start_minus_start = blockIdx.y;
    const int gap_width = blockIdx.z + 1;
    const int start = threadIdx.x;
    const int end = start + width + gap_width;

    if(end>=L){
        return;
    }

    const int gap_start = start + gap_start_minus_start + 1;
    const int gap_end = gap_start + gap_width;

    if(gap_start - start >width-1)
    {
        return;
    }

    const int L2 = L*L;
    const int L3 = L2*L;
    const int L4 = L3*L;
    const float * const s_d = alpha_d + b_idx * L4;
    const float * const s_c = alpha_c + b_idx * L2;


    float tmp_max = s_c[start*L + gap_start] + s_c[gap_end*L + end];
    float tmp_idx = -1;

    for(int split=start + 1; split<gap_start; split++){
        float tmp = s_c[start*L + split] + s_d[split*L3+ gap_start*L2 + gap_end*L + end];
        if (tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = split;
        }
        tmp = s_c[split*L + gap_start] + s_d[start*L3 + split*L2 + gap_end*L + end];
        if ( tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = L + split;
        }

        for(int split2 = gap_end+1; split2 < end; split2++){
            tmp = s_d[start*L3 + split*L2 + split2*L+end] + s_d[split*L3+gap_start*L2+gap_end*L+split2];
            if (tmp > tmp_max){
                tmp_max = tmp;
                tmp_idx = -(split*L + split2);
            }
        }
    }

    for(int split = gap_end+1; split < end; split++){
        float tmp = s_c[gap_end*L + split] + s_d[start*L3 + gap_start*L2 + split*L + end];
        if ( tmp > tmp_max){
           tmp_max = tmp;
           tmp_idx = 2*L + split;
         }
         tmp = s_c[split*L + end] + s_d[start*L3 + gap_start*L2 + gap_end*L + split];
         if (tmp > tmp_max){
            tmp_max = tmp;
            tmp_idx = 3*L + split;
         }
    }


    alpha_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end] = tmp_max + s_span_d[b_idx*L4+start*L3+gap_start*L2+gap_end*L+end];
    alpha_d[b_idx*L4+gap_start*L3+start*L2+gap_end*L+end] = tmp_idx;
}

void cuda_argmax(float *s_span_c, float *s_span_d, float *alpha_c, float *alpha_d, int B, int L)
{
    for(int w=2; w<L; w++){
        dim3 gridDim(B);
        dim3 blockDim(L-w);
        kernel_argmax_c<<<gridDim, blockDim>>>(s_span_c,alpha_c,alpha_d, B, L, w);
        if(w<L-1){
            dim3 gridDim3(B,(w-1), (L-w));
            dim3 blockDim3(L-w);
            kernel_argmax_d<<<gridDim3, blockDim3>>>(s_span_d, alpha_c, alpha_d, B, L, w);
        }
    }
}

void cuda_argmax_on3(float *s_span_c, float *s_span_d, float *alpha_c, float *alpha_d, int B, int L)
{
    for(int w=2; w<L; w++){
        dim3 gridDim(B);
        dim3 blockDim(L-w);
        kernel_argmax_c<<<gridDim, blockDim>>>(s_span_c,alpha_c,alpha_d, B, L, w);
        if(w<L-1){
            dim3 gridDim3(B,(w-1), (L-w));
            dim3 blockDim3(L-w);
            kernel_argmax_d_on3<<<gridDim3, blockDim3>>>(s_span_d, alpha_c, alpha_d, B, L, w);
        }
    }
}

void cuda_argmax_on6wn(float *s_span_c, float *s_span_d, float *alpha_c, float *alpha_d, int B, int L)
{
    for(int w=2; w<L; w++){
        dim3 gridDim(B);
        dim3 blockDim(L-w);
        kernel_argmax_c<<<gridDim, blockDim>>>(s_span_c,alpha_c,alpha_d, B, L, w);
        if(w<L-1){
            dim3 gridDim3(B,(w-1), (L-w));
            dim3 blockDim3(L-w);
            kernel_argmax_d_on6wn<<<gridDim3, blockDim3>>>(s_span_d, alpha_c, alpha_d, B, L, w);
        }
    }
}


